To exploit the code to make it delete a file, my method of choice was to use the 

	int unlink(const *char pathname);


function in the header file <unistd.h>. Luckily, the source code already includes this file, so getting the address for this program was a matter of going to gdb
and entering the command

	(gdb) disas unlink.

This output the following:

Dump of assembler code for function unlink:
   0xf7ea8170 <+0>:     mov    %ebx,%edx
   0xf7ea8172 <+2>:     mov    0x4(%esp),%ebx
   0xf7ea8176 <+6>:     mov    $0xa,%eax
   0xf7ea817b <+11>:    call   *%gs:0x10
   0xf7ea8182 <+18>:    mov    %edx,%ebx
   0xf7ea8184 <+20>:    cmp    $0xfffff001,%eax
   0xf7ea8189 <+25>:    jae    0xf7ea818c <unlink+28>
   0xf7ea818b <+27>:    ret
   0xf7ea818c <+28>:    call   0xf7ef7779 <__x86.get_pc_thunk.cx>
   0xf7ea8191 <+33>:    add    $0xd1e6f,%ecx
   0xf7ea8197 <+39>:    mov    -0xe8(%ecx),%ecx
   0xf7ea819d <+45>:    neg    %eax
   0xf7ea819f <+47>:    mov    %eax,%gs:(%ecx)
   0xf7ea81a2 <+50>:    or     $0xffffffff,%eax
   0xf7ea81a5 <+53>:    ret
End of assembler dump.

So the address of interest is 0xf7ea8170. Now our objective is to use the fact that the read_config(...) function in the source code has a bug that allows us to submit a .txt
file via the -C flag which can overwrite memory in the stack, causing a stack buffer overflow. We can use this to overwrite the stack's contents in a clever way so that we can
overwrite the return address to this unlink function. This way we can return to it after the read_config(...) function completion. However, there is a caveat.

One issue in using the unlink(const *char pathname) function is that it requires an argument. If we are working with x86-64, we aim to change the %rdi register, which is the
default first argument. However, the compilation specified in this project included the -m32 flag, which resulted in assembly using x86 convention. The convention for passing
arguments there is to push it onto the stack. Thus we have to determine where exactly on the stack to store our pointer. This leads to the next issue! We have to store an address
to a null-terminated C-string as our argument, meaning I need a safe location to place a C-string and I need to determine it's address in memory.

So with all this being said, I created the file attack.txt, which contains the exploit. I have attached it in this project. It begins with a valid command from the read_config
function "path=...". If this was not included, then the function would just exit using exit(0) since it could not process the command. The function had to be tricked into believing
it was processing a valid command. It was only necessary to say "path=" once to avoid the immediate program termination threatened by the function. After that, particular character
values were placed strategically in the text file. For instance, the string "target.txt" was placed in there, along with the addresses, written byte-for-byte in ASCII form. This was
one of the most challenging parts of constructing the file, since Emacs had very difficult documentation to follow in terms of determining how to properly enter extended ASCII values
into the file. For instance, how does one insert a NULL character (0x00)? After repeatedly trying to copy paste characters without success, I realized Emacs has a setting called
multi-byte, which allows Emacs to represent particular unique characters outside of ASCII by using more than one byte. The solution I eventually came up with was to try and change
this to unibyte mode (regular one byte per character) and then set the encoding to unix. This seemed to do the trick when trying to insert some character values. Copy pasting still
was not completely effective, so after some research I discovered that one could using the following command,

	printf '\x00' >> attack.txt

to append to a file the character with that particular ASCII value (in this case, the null byte). I could then just move this character to the appropriate location in the file. I ended
up using this strategy for all bytes whose ASCII representation was not on the keyboard.

Another issue I ran into was where to store my C-String. For a while I would use GDB to check the address location to see if the C-string was being read correctly. It would always say
"target.txt", but then the unlink function would return -1, indicating failure (and the file was not deleted). What I eventually discovered was that other function calls were being made
in unlink, and those function calls were overwriting my C-String, which was placed in an inappropriate location. I placed the C-string farther away, and it began to work correctly.